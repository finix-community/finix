{ config, pkgs, lib, ... }:
let
  cfg = config.services.dhcpcd;

  format =
    let
      format' = pkgs.formats.keyValue {
        listToValue = v: lib.concatMapStringsSep "," toString v;
        mkKeyValue = k: v: if v == true then k else "${k} ${toString v}";
      };
    in
    {
      type = format'.type;
      generate = name: value: format'.generate name (lib.filterAttrs (_: v: v != false) value);
    };
in
{
  options.services.dhcpcd = {
    enable = lib.mkEnableOption "dhcpd";

    package = lib.mkOption {
      type = lib.types.package;
      default = if config.services.udev.enable
        then pkgs.dhcpcd
        else pkgs.dhcpcd.override { udev = null; };
      defaultText = lib.literalExpression "pkgs.dhcpcd";
    };

    settings = lib.mkOption {
      type = lib.types.submodule {
        freeformType = format.type; # FIXME: types.record { }
        options = {
          # FIXME: why do booleans get turned into "1" if you don't declare them as booleans?
          background = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          broadcast = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          duid = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          hostname = lib.mkOption {
            type = with lib.types; nullOr str;
            default = null;
          };

          hostname_short = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv4only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_fork = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own_default = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noalias = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noarp = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nogateway = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv4ll = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nolink = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          quiet = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          release = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          waitip = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          xidhwaddr = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };
        };
      };
      default = { };
    };

    configFile = lib.mkOption {
      type = lib.types.path;
      default = format.generate "dhcpcd.conf" (lib.filterAttrs (_: v: v != null) cfg.settings);
      defaultText = "configuration file generated by nixos";
    };
  };

  config = lib.mkIf cfg.enable {
    services.dhcpcd.settings = {
      # Inform the DHCP server of our hostname for DDNS.
      hostname = "";

      # A list of options to request from the DHCP server.
      option = [ "domain_name_servers" "domain_name" "domain_search" "host_name" "classless_static_routes" "ntp_servers" "interface_mtu" ];

      # A ServerID is required by RFC2131.
      # Commented out because of many non-compliant DHCP servers in the wild :(
      #require dhcp_server_identifier

      # A hook script is provided to lookup the hostname if not set by
      # the DHCP server, but it should not be run by default.
      nohook = "lookup-hostname";

      # Ignore peth* devices; on Xen, they're renamed physical
      # Ethernet cards used for bridging.  Likewise for vif* and tap*
      # (Xen) and virbr* and vnet* (libvirt).
      denyinterfaces = [ "lo" "peth*" "vif*" "tap*" "tun*" "virbr*" "vnet*" "vboxnet*" "sit*" ];

      # Immediately fork to background if specified, otherwise wait for IP address to be assigned
      waitip = true;
    };

    # NOTE: temporarily disable this because it wasn't working properly
    finit.services.dhcpcd = {
      description = "dhcp client";
      command = "${lib.getExe cfg.package} -f ${cfg.configFile}";
    };

    synit.daemons.dhcpcd = let
      # TODO: This should be handled by tmpfiles.
      script = pkgs.execline.passthru.writeScript "dhcpcd-dirs.el" "-s0" ''
        foreground { ln -s /run /var/run }
        foreground { install --directory --owner=dhcpcd /var/db/dhcpcd }
        foreground { install --directory --owner=dhcpcd --group=dhcpcd /var/lib/dhcpcd }
        $@
      '';
    in {
      argv = [ script (lib.getExe cfg.package) "--config" cfg.configFile ];
      provides = [ [ "milestone" "network" ] ];
      restart = "on-error";
      logging.enable = false; # Logs to syslog unfortunately.
    };

    services.tmpfiles.dhcpd.rules = [
      "d /var/db/dhcpcd - dhcpcd"
      "d /var/lib/dhcpcd - dhcpcd dhcpcd"
    ];

    users.users = {
      dhcpcd = {
        group = "dhcpcd";
      };
    };

    users.groups = {
      dhcpcd = { };
    };
  };
}
