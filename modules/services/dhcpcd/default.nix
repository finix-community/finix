{
  config,
  pkgs,
  lib,
  ...
}:
let
  cfg = config.services.dhcpcd;

  format =
    let
      format' = pkgs.formats.keyValue {
        listToValue = v: lib.concatMapStringsSep "," toString v;
        mkKeyValue = k: v: if v == true then k else "${k} ${toString v}";
      };
    in
    {
      type = format'.type;
      generate = name: value: format'.generate name (lib.filterAttrs (_: v: v != false) value);
    };
in
{
  options.services.dhcpcd = {
    enable = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = ''
        Whether to enable [dhcpcd](${pkgs.dhcpcd.meta.homepage}) as a system service.
      '';
    };

    package = lib.mkOption {
      type = lib.types.package;
      default = pkgs.dhcpcd.override {
        withUdev = config.services.udev.enable;
      };
      defaultText = lib.literalExpression ''
        pkgs.dhcpcd.override {
          withUdev = config.services.udev.enable;
        }
      '';
      description = ''
        The package to use for `dhcpcd`.
      '';
    };

    settings = lib.mkOption {
      type = lib.types.submodule {
        freeformType = format.type; # FIXME: types.record { }
        options = {
          # FIXME: why do booleans get turned into "1" if you don't declare them as booleans?
          background = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          broadcast = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          duid = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          hostname = lib.mkOption {
            type = with lib.types; nullOr str;
            default = null;
          };

          hostname_short = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv4only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_fork = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own_default = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noalias = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noarp = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nogateway = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv4ll = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nolink = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          quiet = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          release = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          waitip = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          xidhwaddr = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };
        };
      };
      default = { };
    };

    configFile = lib.mkOption {
      type = lib.types.path;
      default = format.generate "dhcpcd.conf" (lib.filterAttrs (_: v: v != null) cfg.settings);
      defaultText = "configuration file generated by nixos";
    };
  };

  config = lib.mkIf cfg.enable {
    services.dhcpcd.settings = {
      # Inform the DHCP server of our hostname for DDNS.
      hostname = "";

      # A list of options to request from the DHCP server.
      option = [
        "domain_name_servers"
        "domain_name"
        "domain_search"
        "host_name"
        "classless_static_routes"
        "ntp_servers"
        "interface_mtu"
      ];

      # A ServerID is required by RFC2131.
      # Commented out because of many non-compliant DHCP servers in the wild :(
      #require dhcp_server_identifier

      # A hook script is provided to lookup the hostname if not set by
      # the DHCP server, but it should not be run by default.
      nohook = "lookup-hostname";

      # Ignore peth* devices; on Xen, they're renamed physical
      # Ethernet cards used for bridging.  Likewise for vif* and tap*
      # (Xen) and virbr* and vnet* (libvirt).
      denyinterfaces = [
        "lo"
        "peth*"
        "vif*"
        "tap*"
        "tun*"
        "virbr*"
        "vnet*"
        "vboxnet*"
        "sit*"
      ];

      # Immediately fork to background if specified, otherwise wait for IP address to be assigned
      waitip = true;
    };

    # NOTE: temporarily disable this because it wasn't working properly
    finit.services.dhcpcd = {
      description = "dhcp client";
      command = "${lib.getExe cfg.package} -f ${cfg.configFile}";
    };

    synit.daemons.dhcpcd = {
      argv = lib.quoteExecline [
        "if"
        [
          "s6-envuidgid"
          "dhcpcd"
          "forx"
          "-E"
          "-p"
          "DIR"
          [
            "/var/db/dhcpcd"
            "/var/lib/dhcpcd"
          ]
          "if"
          [
            "s6-mkdir"
            "-p"
            "-m"
            "750"
            "$DIR"
          ]
          "s6-chown"
          "-U"
          "$DIR"
        ]

        "dhcpcd"
        "--nobackground"
        "--config"
        cfg.configFile

        # Disable dhcpcd from applying configuation
        # and use a hooks script that communicates
        # with ../../synit/networking.tcl instead.
        "--noconfigure"
        "--script"
        "${pkgs.synit-network-utils}/lib/dhcpcd-hook.tcl"
      ];
      path = [ cfg.package ];
      provides = [
        [
          "milestone"
          "network"
        ]
      ];
      requires = [
        {
          key = [
            "daemon"
            "network-configurator"
          ];
          state = "ready";
        }
      ];
    };

    services.tmpfiles.dhcpd.rules = [
      "d /var/db/dhcpcd - dhcpcd"
      "d /var/lib/dhcpcd - dhcpcd dhcpcd"
    ];

    users.users = {
      dhcpcd = {
        group = "dhcpcd";
      };
    };

    users.groups = {
      dhcpcd = { };
    };
  };
}
