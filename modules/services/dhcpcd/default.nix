{ config, pkgs, lib, ... }:
let
  cfg = config.services.dhcpcd;

  format =
    let
      format' = pkgs.formats.keyValue {
        listToValue = v: lib.concatMapStringsSep "," toString v;
        mkKeyValue = k: v: if v == true then k else "${k} ${toString v}";
      };
    in
    {
      type = format'.type;
      generate = name: value: format'.generate name (lib.filterAttrs (_: v: v != false) value);
    };
in
{
  options.services.dhcpcd = {
    enable = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = ''
        Whether to enable [dhcpcd](${pkgs.dhcpcd.meta.homepage}) as a system service.
      '';
    };

    package = lib.mkOption {
      type = lib.types.package;
      default = pkgs.dhcpcd.override {
        withUdev = config.services.udev.enable;
      };
      defaultText = lib.literalExpression ''
        pkgs.dhcpcd.override {
          withUdev = config.services.udev.enable;
        }
      '';
      description = ''
        The package to use for `dhcpcd`.
      '';
    };

    settings = lib.mkOption {
      type = lib.types.submodule {
        freeformType = format.type; # FIXME: types.record { }
        options = {
          # FIXME: why do booleans get turned into "1" if you don't declare them as booleans?
          background = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          broadcast = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          duid = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          hostname = lib.mkOption {
            type = with lib.types; nullOr str;
            default = null;
          };

          hostname_short = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv4only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6only = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_fork = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6ra_own_default = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          ipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noalias = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noarp = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nogateway = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv4ll = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          noipv6rs = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          nolink = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          quiet = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          release = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          waitip = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };

          xidhwaddr = lib.mkOption {
            type = with lib.types; nullOr bool;
            default = null;
          };
        };
      };
      default = { };
    };

    configFile = lib.mkOption {
      type = lib.types.path;
      default = format.generate "dhcpcd.conf" (lib.filterAttrs (_: v: v != null) cfg.settings);
      defaultText = "configuration file generated by nixos";
    };
  };

  config = lib.mkIf cfg.enable {
    services.dhcpcd.settings = {
      # Inform the DHCP server of our hostname for DDNS.
      hostname = "";

      # A list of options to request from the DHCP server.
      option = [ "domain_name_servers" "domain_name" "domain_search" "host_name" "classless_static_routes" "ntp_servers" "interface_mtu" ];

      # A ServerID is required by RFC2131.
      # Commented out because of many non-compliant DHCP servers in the wild :(
      #require dhcp_server_identifier

      # A hook script is provided to lookup the hostname if not set by
      # the DHCP server, but it should not be run by default.
      nohook = "lookup-hostname";

      # Ignore peth* devices; on Xen, they're renamed physical
      # Ethernet cards used for bridging.  Likewise for vif* and tap*
      # (Xen) and virbr* and vnet* (libvirt).
      denyinterfaces = [ "lo" "peth*" "vif*" "tap*" "tun*" "virbr*" "vnet*" "vboxnet*" "sit*" ];

      # Immediately fork to background if specified, otherwise wait for IP address to be assigned
      waitip = true;
    };

    # NOTE: temporarily disable this because it wasn't working properly
    finit.services.dhcpcd = {
      description = "dhcp client";
      command = "${lib.getExe cfg.package} -f ${cfg.configFile}";
    };

    synit.daemons.dhcpcd = {
      argv = lib.quoteExecline [
        "if" [
          "s6-envuidgid" "dhcpcd"
          "forx" "-E" "-p" "DIR" [ "/var/db/dhcpcd" "/var/lib/dhcpcd" ]
          "if" [ "s6-mkdir" "-p" "-m" "750" "$DIR" ]
          "s6-chown" "-U" "$DIR"
        ]

        "dhcpcd"
        "--nobackground"
        "--config" cfg.configFile

        # Disable dhcpcd from applying configuation
        # and use a hooks script that communicates
        # with ../../synit/networking.tcl instead.
        "--noconfigure"
        "--script" "${pkgs.synit-network-utils}/lib/dhcpcd-hook.tcl"
      ];
      path = [ cfg.package ];
      provides = [ [ "milestone" "network" ] ];
      requires = [
        { key = [ "daemon" "network-configurator"  ]; state = "ready"; }
      ];
    };

    services.tmpfiles.dhcpd.rules = [
      "d /var/db/dhcpcd - dhcpcd"
      "d /var/lib/dhcpcd - dhcpcd dhcpcd"
    ];

    users.users = {
      dhcpcd = {
        group = "dhcpcd";
      };
    };

    users.groups = {
      dhcpcd = { };
    };
  };
}
